/**
 * =============================
 *
 * Performs some source code analysis to extract the documentation
 * of the API methods.
 *
 * TODO Check @module == module file/var
 * TODO Check @param in url
 * TODO One instance for each request
 *
 * =============================
 *
 * Attributes : /
 *
 * Methods : /
 *
 * Events : /
 *
 * =============================
 */



/**
 * Load modules
 */

// Built-in
var fs = require('fs');
// Global
var logger = require('logger');
var Dao = require('db').Dao;
var dbCommander = require('dbCommander');
var config = require('config');
var utils = require('utils');



/**
 * Variables
 */

// DAO
var apiDao = new Dao('api', 'doc');
var configDao = new Dao('config');



/**
 * Analyse all the api
 */

var analyze = function () {
	logger.info('[API Analyzer] Start API analyse');

	var tmpPath = config.get('serviceTmpDir') + 'sources/';
	var apiPath = tmpPath + 'API/'
	var rootFile = apiPath + 'node_modules/server.js';

	// Get source code of application
	_getSources(tmpPath, function () {
		// Parsing
		var modules = _parseRootFile(rootFile);
		modules.forEach(function (module) {
			_parseModuleComments(apiPath, module)
		});

		// Insert in DB
		modules.forEach(function (module) {
			if (!module.name) {
				module.name = 'Unknown';
			}
			apiDao.findOne({var: module.var}, function (item) {
				if (item) {
					apiDao.update(item._id, module);
				} else {
					apiDao.insert(module);
				}
			});
		});

		// Logging
		var nbRoutes = 0;
		modules.forEach(function (module) {
			nbRoutes += module.routes.length;
		});
		logger.info('[API Analyzer] API analyze done: ' + nbRoutes + ' routes found, ' + modules.length + ' modules found');

		// Cleand sources
		_cleanSources(tmpPath);
	});
};



/**
 * Get the source-code of the API
 */

var _getSources = function (path, callback) {
	// Create a new empty directory
	if (fs.existsSync(path)) {
		utils.rmdirrfSync(path);
	}
	fs.mkdirSync(path);
	// Get git configuration
	configDao.findOne({name: 'git'}, function (git) {
		// Create URL
		var url = git.url.replace('://', '://' + git.user + ':' + git.password + '@');
		// Start retrieving sources
		var parameters = {
			url:			url,
			destination:	path
		};
		dbCommander.command('git-clone', parameters, function (result) {
			if (callback) callback();
		});
	});
};



/**
 * Clean tmp directory, delete downloaded sources
 */

var _cleanSources = function (path) {
	utils.rmdirrfSync(path);
};



/**
 * Get the server and the basic routes information
 * only the root file is parsed, and no comments
 * are parsed. Only the route definitions.
 *
 * Read the file a second time for the modules.
 */

var _parseRootFile = function (rootFile) {
	// Modules {var: 'devices', file: './routes/devices.js', routes: []}
	// Routes {method: 'get', url: '/device', module: 'devices', function: 'findAll'}
	var modules = [];

	// Get the file contents
	var fileContents = fs.readFileSync(rootFile, 'UTF-8');

	// Search for modules
	var moduleRegExp = new RegExp('\\s*var\\s*' + '(\\S*)' + '\\s=\\srequire\\(' + '(?:\'|")\.\./(routes/\\S*)(?:\'|")\\);');
	fileContents.split('\n').forEach(function (line) {
		var match = moduleRegExp.exec(line);
		if (match) {
			modules.push({
				var:	match[1],
				file:	match[2],
				routes:	[]
			});
			logger.info('[API Analyzer] Module found: ' + match[1] + '  |  ' + match[2]);
		}
	});

	// Search for server and routes
	var server;
	var serverRegExp = /\s*var\s*(\S*)\s*=.*express\(.*\)\s*;\s*/;
	fileContents.split('\n').forEach(function (line) {
		// Search for server
		if (!server) {
			var match = serverRegExp.exec(line);
			if (match) {
				server = match[1];
				logger.info('[API Analyzer] Server found: ' + server);
			}
		}
		// Search for routes of this server
		else {
			// The Regexp is decomposed for lecture: empty + server + method.( + (firstArgument, + secondArgument);
			var routeRegExp = new RegExp('\\s*' + server + '\\.(\\S*)\\(' + '(?:\'|")(\\S*)(?:\'|"),' + '\\s*(\\S*)\\.(\\S*)\\);');
			var match = routeRegExp.exec(line);
			if (match) {
				modules.forEach(function (mod) {
					if (mod.var === match[3]) {
						mod.routes.push({
							method:		match[1],
							url:		match[2],
							function:	match[4]
						});
					}
				})
				logger.info('[API Analyzer] Route found: ' + match[1] + '  |  ' + match[2] + '  |  ' + match[3] + '  |  ' + match[4]);
			}
		}
	});

	// Return modules
	return modules;
};



/**
 * Parse a module file and get all his API Routes documentation
 * Take in input a module {var: ..., file: ...}
 */

var _parseModuleComments = function (appPath, module) {
	logger.log('[API Analyzer] Parsing module: ' + module.var);
	// Get the file contents
	var fileContents = fs.readFileSync(appPath  + module.file, 'UTF-8');

	// Regexp
	var startCommentRegExp = /\/\*\*/;
	var stopCommentRegExp = /\*\//;
	var commentRegExp = /\s*\*\s*(\S*.*\S*)\s*$/;
	var inComment = false;
	var comment = '';
	// Read each line
	fileContents.split('\n').forEach(function (line) {
		// Search for comment
		if (!inComment) {
			var match = startCommentRegExp.exec(line);
			if (match) {
				inComment = true;
				comment = '';
			}
		}
		// If in a comment
		else {
			// Search for end of comment
			var match = stopCommentRegExp.exec(line);
			if (match) {
				inComment = false;
				_parseComment(module, comment);
			}
			// Comment content found
			else {
				comment += commentRegExp.exec(line)[1] + '\n';
			}
		}
	});
};



/**
 * Parse a comment and add the information found
 * in the global variables.
 * Require the module and the comment to work.
 */

var _parseComment = function (module, comment) {
	// Look for information
	var infos = {
		params:	[]
	};
	var nameRegExp = /@name\s*(.*)/;
	var methodRegExp = /@method\s*(.*)/;
	var paramRegExp = /@param\s*(\S*)\s*{(\S*)}\s*(\S*)\s*(.*)/;	// @param paramName {types} optional/required description
	var moduleRegExp = /@module\s*(.*)/;
	var exampleRegExp = /@example\s*(.*)/;
	comment.split('\n').forEach( function (line) {
		var match;
		switch (true) {
			case methodRegExp.test(line) :
				match = methodRegExp.exec(line);
				infos.function = match[1];
				break;
			case moduleRegExp.test(line) :
				match = moduleRegExp.exec(line);
				infos.module = match[1];
				break;
			case nameRegExp.test(line) :
				match = nameRegExp.exec(line);
				infos.name = match[1];
				break;
			case exampleRegExp.test(line) :
				match = exampleRegExp.exec(line);
				infos.example = match[1];
				break;
			case paramRegExp.test(line) :
				match = paramRegExp.exec(line);
				infos.params.push({
					name:			match[1],
					type:			match[2],
					require:		match[3],
					description:	match[4]
				});
				break;
			default:
				infos.description = infos.description === undefined ? line : infos.description + ' ' + line;
		}
	});

	// If it is an API method, copy for each route the infos
	if (infos.function) {
		module.routes.forEach(function (route) {
			if (route.function == infos.function) {
				for (var key in infos) {
					if (infos.hasOwnProperty(key)) {
						route[key] = infos[key];
					}
				}
			}
		});
		logger.info('[API Analyzer] Information found on route ' + infos.function + ': ' + infos.name + ' | ' + infos.description + ' | ' + infos.params.length + ' parameters');
	}

	// If it is an API module, copy the module infos
	else if (infos.module) {
		for (var key in infos) {
			if (infos.hasOwnProperty(key)) {
				module[key] = infos[key];
			}
		}
		logger.info('[API Analyzer] Information found on module ' + infos.module + ': ' + infos.name + ' | ' + infos.description);
	}
};



/**
 * Exports
 */

// Methods
exports.analyze = analyze;