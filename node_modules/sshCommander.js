/**
 * =============================
 *
 * Execute commands on remote hosts through SSH.
 * All the commands/scripts availlable in DB can
 * be executed.
 *
 * The execution is based on a common maintenance
 * user that must be created on the remote host.
 * The commands are base64 encoded and put into a
 * file that is copied on the server to be executed.
 *
 * =============================
 *
 * Attributes : /
 *
 * Methods :
 *		- command(hostname, name, parameters, [callback])
 *		- daemon(hostname, name, parameters, [callback])
 *
 * Events : /
 *
 * =============================
 */



/**
 * Load modules
 */

// Built-in
var os = require('os');
var dns = require('dns');
var fs = require('fs');
// Global
var logger = require('logger');
var config = require('config');
var dbCommander = require('dbCommander');
var db = require('db');



/**
 * Variables
 */

// DAO
var commandDao = new db.Dao('commands');
var scriptDao = new db.Dao('scripts');
var serverDao = new db.Dao('servers');
// List of ssh private keys we have to connect to servers
var keys = [];



/**
 * Execute a command/script on the given host.
 *
 * This command uses the dbCommander to execute commands,
 * so the results are the same. It returns an object with
 * the output, code...
 *
 * @param hostname the hostname of the remote server
 * @param host the host to connect to, it may be an ip or hostname
 * @param name the command name (DB) to execute
 * @param parameters the parameters of the command
 * @param callback return an error, or null and the command result
 */
var command = function (hostname, name, parameters, callback) {
	// Get host to connect to
	_getHost(hostname, function (err, host) {
		if (err) {
			if (callback) callback(new Error('[MaintenanceCommander] Unable to execute command: ' + err.message));
		} else {
			// Check if the maintenance user key is present
			_checkMaintenanceUserKey(hostname, function (err) {
				if (err) {
					if (callback) callback(new Error('[MaintenanceCommander] Unable to execute command: ' + err.message));
				} else {
					// Execute the command
					_command(false, hostname, host, name, parameters, callback);
				}
			});
		}
	});
};

/**
 * Execute a command/script on the given host in
 * daemon mode.
 *
 * This command uses the dbCommander to execute commands,
 * so the results are the same. It returns an event-emitter
 * to listen to for data/end.
 *
 * @param hostname the hostname of the remote server
 * @param host the host to connect to, it may be an ip or hostname
 * @param name the command name (DB) to execute
 * @param parameters the parameters of the command
 * @param callback return an error, or null and an event-emitter
 */
var daemon = function (hostname, name, parameters, callback) {
	// Get host to connect to
	_getHost(hostname, function (err, host) {
		if (err) {
			if (callback) callback(new Error('[MaintenanceCommander] Unable to execute command: ' + err.message));
		} else {
			// Check if the maintenance user key is present
			_checkMaintenanceUserKey(hostname, function (err) {
				if (err) {
					if (callback) callback(new Error('[MaintenanceCommander] Unable to execute command: ' + err.message));
				} else {
					// Execute the command
					_command(true, hostname, host, name, parameters, callback);
				}
			});
		}
	});
};

/**
 * Execute a command/script on the given host in
 * daemon mode or not.
 *
 * This command uses the dbCommander to execute commands,
 * so the results are the same (event-emitter/result)
 *
 * @param isDaemon if the command must be executed as daemon or not
 * @param hostname the hostname of the remote server
 * @param host the host to connect to, it may be an ip or hostname
 * @param name the command name (DB) to execute
 * @param parameters the parameters of the command
 * @param callback return an error, or null and the command response.
 * it may be the command result, or an event-emitter for a daemon.
 */
var _command = function (isDaemon, hostname, host, name, parameters, callback) {
	// Find command in DB
	commandDao.findOne({name: name}, function (err, dbCommand) {
		// Check if command exists, if not, exit...
		if (dbCommand === undefined || dbCommand === null) {
			if (callback) callback(new Error('Unable to find command "' + name + '" in DB'));
			return;
		}
		// Get ssh Params
		var sshParams = {
			key:		config.serverTmpDir + hostname + '.key',
			username:	'oms', // TODO get from config
			host:		host
		};
		// If it is a script
		if (dbCommand.script !== undefined) {
			// Check if script exists on server
			sshParams.filename = config.serverTmpDir + 'scripts/' + dbCommand.script + '_' + dbCommand.version;
			dbCommander.command('check-script', sshParams, function (result) {
				// Execute function
				var execute = function () {
					sshParams.arguments = _prepareString(dbCommand.arguments, parameters);
					if (isDaemon) {
						dbCommander.daemon('sshScript', sshParams, function (exec) {
							if (callback) callback(null, exec);
						});
					} else {
						dbCommander.command('sshScript', sshParams, function (result) {
							if (callback) callback(null, result);
						});
					}
				};
				// If no script, copy it
				if (result.code != 0) {
					_copyScript(hostname, dbCommand.script, sshParams, function (err) {
						if (err) {
							if (callback) callback(err);
						} else {
							execute();
						}
					});
				}
				// Execute
				else {
					execute();
				}
			});
		}
		// If it is a command
		else {
			sshParams.command = _prepareBase64String(dbCommand.command, parameters);
			dbCommander.command('sshCommand', sshParams, function (result) {
				if (callback) callback(null, result);
			});
		}
	});
};

/**
 * Copy script on the remote host
 *
 * @param server the server hostname to copy to
 * @param script the script name
 * @param sshParams ssh params object containing username/host/key
 * @param callback a callback returning nothing or err if error
 */
var _copyScript = function (server, script, sshParams, callback) {
	logger.info('[SSH Commander] Copy script "' + script + '" on ' + server);
	scriptDao.findOne({name: script}, function (err, dbScript) {
		// Script found
		if (dbScript) {
			// Get server config to know where store the script
			config.get(server, null, function (err, conf) {
				// Config got
				if (conf) {
					sshParams.filename = conf.serverTmpDir + 'scripts/' + script + '_' + dbScript.version;
					sshParams.script = dbScript.content;
					dbCommander.command('copy-script', sshParams, function (result) {
						logger.info('[SSH Commander] Script "' + script + '" copied  on server ' + server);
						if (callback) callback(null);
					});
				}
				// Config not found
				else {
					if (callback) callback(new Error('Unable to load config for server: ' + err.message));
				}
			});
		}
		// Script not found
		else {
			if (callback) callback(new Error('Script ' + script + 'not found'));
		}
	});
};

/**
 * Get maintenance host for server.
 * If a host is set in the config, use it.
 * If it is not resolvable, throw an error.
 * Else, check if the hostname is resolvable.
 * If yes, use it, else throw an error.
 *
 * @param hostname the hostname to get the host
 * @param callback return an error, or null and the host to connect to
 */
var _getHost = function (hostname, callback) {
	logger.info('[SSH Commander] get IP for "' + hostname + '"')
	serverDao.findOne({hostname: hostname}, function (err, server) {
		if (server) {
			// Config
			var host = server.config['maintenanceHost'];
			if (host) {
				// If the host is an ip, lookup return the same ip
				dns.lookup(host, function (err, ip) {
					if (ip) {
						logger.info('[SSH Commander] IP for "' + hostname + '" found: ' + ip);
						if (callback) callback(null, host);
					} else {
						if (callback) callback(new Error('Config hostname not resolvable: ' + host));
					}
				});
			}
			// Hostname
			else {
				dns.lookup(hostname, function (err, ip) {
					if (ip) {
						logger.info('[SSH Commander] IP for "' + hostname + '" found: ' + ip);
						if (callback) callback(null, hostname);
					} else {
						if (callback) callback(new Error('Config hostname not resolvable: ' + hostname));
					}
				});
			}
		} else {
			if (callback) callback(new Error('Server not found in database: ' + hostname));
		}
	});
};

/**
 * Prepare the string encoded in base 64 by decoding it,
 * replacing the {{}} by the parameters, and re-encoded it
 * in base64.
 *
 * The parameters must be an object with keys will be searched
 * in the string, and replaced by the value.
 *
 * @param encodedString string encoded in base64
 * @param parameters an object containing kev-values to replace in the string
 * @return a base64 encoded string with the parameters replaced in
 */
var _prepareBase64String = function (encodedString, parameters) {
	var preparedString = _prepareString(encodedString, parameters);
	preparedString = new Buffer(preparedString).toString('base64');
	return preparedString;
};

/**
 * Prepare the string encoded in base 64 by decoding it and
 * replacing the {{}} by the parameters.
 *
 * The parameters must be an object with keys will be searched
 * in the string, and replaced by the value.
 *
 * @param encodedString string encoded in base64
 * @param parameters an object containing kev-values to replace in the string
 * @return a string with the parameters replaced in
 */
var _prepareString = function (encodedString, parameters) {
	var preparedString = new Buffer(encodedString, 'base64').toString('utf-8');
	for (var parameter in parameters) {
		var regexp = new RegExp('{{' + parameter + '}}', 'g');
		preparedString = preparedString.replace(regexp, parameters[parameter]);
	}
	return preparedString;
};

/**
 * Check if the ssh private key is present to connect,
 * if not, try to add it, else, callback an error.
 *
 * @param hostname hostname of the server
 * @param callback called when done, returns an error if no key can be added
 */
var _checkMaintenanceUserKey = function (hostname, callback) {
	// If the key file is already found before
	if (keys.indexOf(hostname) !== -1) {
		if (callback) callback(null);
	}
	// If not in cache
	else {
		var key = config.serverTmpDir + hostname + '.key';
		// Check if key-file is present
		if (fs.existsSync(key)) {
			keys.push(hostname);
			if (callback) callback(null);
		}
		// Add the key file
		else {
			serversDao.findOne({hostname: server}, function (err, server) {
				// If no server for this hostname
				if (!server) {
					if (callback) callback(new Error('Unable to find a server for the hostname: ' + hostname));
					return;
				}
				// If no private key in DB
				if (!server.config.maintenancePrivateKey) {
					if (callback) callback(new Error('Unable to find a private key for server: ' + hostname));
					return;
				}
				// Add the private key file
				fs.writeFileSync(key, server.config.maintenancePrivateKey);
				fs.chmodSync(key, '600');
				// Callback
				logger.info('[SSH Commander] SSH Key added for maintenance user');
				if (callback) callback(null);
			});
		}
	}
};



/**
 * Exports
 */

// methods
exports.command = command;
exports.daemon = daemon;