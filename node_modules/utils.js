/**
 * =============================
 *
 * Deliver some utility methods to all the services.
 * For example: compare versions, rm -rf, mkdir -p...
 *
 * =============================
 *
 * Attributes : /
 *
 * Methods :
 *		- mkdirpSync(directory)
 *		- rmdirrfSync(path)
 *		- rmdirrf(path, [callback])
 *		- compareVersions(v1, v2)
 *		- makePassword()
 *
 * Events : /
 *
 * =============================
 */



/**
 * Load modules
 */

var fs = require('fs');
var mongo = require('mongodb');



/**
 * Create a directory and all his parents if needed.
 * The directory must be given on the following example :
 *		/parent/parent/dir
 * The first slash is important, and no last slash must be given
 *
 * @param directory the full path to create
 */

var mkdirpSync = function (directory) {
	var split = directory.split('/');
	split.shift();
	var dir = '';
	for (var i in split) {
		dir += '/' + split[i];
		if (!fs.existsSync(dir)) {
			fs.mkdirSync(dir);
		}
	}
};



/**
 * Delete recursively a directory and all his contents.
 * If the directory not exists, does nothing.
 *
 * This method is synchronous
 *
 * @param path the directory to delete recursively
 */

var rmdirrfSync = function(path) {
	if (fs.existsSync(path)) {
		var files = fs.readdirSync(path);
		files.forEach(function (file, index) {
			var curPath = path + "/" + file;
			if (fs.statSync(curPath).isDirectory()) {
				rmdirrfSync(curPath);
			} else {
				fs.unlinkSync(curPath);
			}
		});
		fs.rmdirSync(path);
	}
};



/**
 * Delete recursively a directory and all his contents.
 * If the directory not exists, does nothing.
 *
 * This method is asynchronous
 *
 * @param path the directory to delete recursively
 * @param callback an error or null
 */

var rmdirrf = function(path, callback) {
	var rmdirParent = function() {
		fs.rmdir(path, function (err) {
			if (!err && callback) callback('[Utils] Unable to delete directory: ' + err.message);
		});
	};
	fs.exists(path, function (exists) {
		if (exists) {
			fs.readdir(path, function (error, files) {
				files.forEach(function (file, index) {
					var curPath = path + "/" + file;
					fs.stat(curPath, function (error, stat) {
						if (stat.isDirectory()) {
							rmdirrf(curPath, rmdirParent);
						} else {
							fs.unlink(curPath, rmdirParent);
						}
					});
				});
			});
		}
	});
};



/**
 * Compare version numbers.
 * If:
 *		v1 < v2		-> -1
 *		v1 == v2	-> 0
 *		v1 > v2		-> 1
 *
 * The version number MUST be at the form : number(.number)*
 * For example:
 *		1.0			= 1
 * 		0.0.1
 *		0.10.1
 *		10.17.65	= 10.017.65
 *
 * @param v1 version number 1
 * @param v2 version number 2
 * @return 0 if the versions ar equal, positive if v1 is greather to v2, negative if v1 is lower than v2
 */

var compareVersions = function (v1, v2) {
	console.log("AA: #" + v1 + "# #" + v2 + "#");
	// Check if version numbers are right
	var regex = /\d+(\.\d+)*/;
	if (!regex.test(v1)) {
		return new Error('The first argument is not a valid version number: ' + v1);
	}
	if (!regex.test(v2)) {
		return new Error('The second argument is not a valid version number: ' + v2);
	}
	// Split version numbers
	var v1Split = v1.split('.');
	var v2Split = v2.split('.');
	// Compare
	for (var i = 0; i < Math.max(v1Split.length, v2Split.length); i++) {
		if (v1Split[i] === undefined) { v1Split[i] = 0; }
		if (v2Split[i] === undefined) { v2Split[i] = 0; }
		if (v1Split[i] < v2Split[i]) { return -1; }
		if (v1Split[i] > v2Split[i]) { return 1; }
	}
	// If not found one greather than another, they are equal...
	return 0;
};



/**
 * Generate a random password of 20 characters containing
 * nubmers and letters (up/down case)
 *
 * @return a random password fo 20 characters
 */

var makePassword = function () {
	var length = 20;
	var characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
	var password = '';
	for (var i=0; i<length; i++) {
		var index = Math.floor(Math.random() * (characters.length));
		password += characters[index];
	}
	return password;
};



/**
 * Return a random 24char token.
 */

var getToken = function () {
	return (new mongo.ObjectID()).toHexString();
};



/**
 * Exports
 */

// Methods
exports.mkdirpSync = mkdirpSync;
exports.rmdirrf = rmdirrf;
exports.rmdirrfSync = rmdirrfSync;
exports.compareVersions = compareVersions;
exports.makePassword = makePassword;
exports.getToken = getToken;