/**
 * Load modules
 */

// Built-in
var mongo = require('mongodb');
var async = require('async');
// Global
var logger = require('logger');



/**
 * Variables
 */

// DB Server
var db = {};
// BSON
var BSON = mongo.BSONPure;



/**
 * Open a database connection
 * If an argument is missing, callback an error
 * If database already opened, just callback and return
 *
 * The database argument can be an array or a string to
 * open multiple connections once.
 *
 * @param host the database host to connect with (hostname or ip)
 * @param port the database port to connect with
 * @param databases the database(s) to connect to, may be a string or an array to open multiple databases
 * @param callback a function called after the database(s) are opened, first argument is en error and may be null
 */
var open = function (host, port, databases, callback) {
	// Check for missing or invalid arguments
	if (host === undefined) {
		if (callback) callback(new Error('[DB] Unable to open database: undefined host'));
		return;
	}
	if (port === undefined) {
		if (callback) callback(new Error('[DB] Unable to open database: undefined port'));
		return;
	}
	if (databases === undefined) {
		if (callback) callback(new Error('[DB] Unable to open database: undefined database'));
		return;
	}
	if (!(databases instanceof Array) && typeof databases !== 'string') {
		if (callback) callback(new Error('[DB] Unable to open database: database(s) argument must be an array or a string'));
		return;
	}

	// Open a single database
	if (databases instanceof Array) {
		// Add host/port information
		for (var key in databases) {
			databases[key] = {host: host, port: port, database: databases[key]};
		}
		// Open each database
		async.each(databases, _openDatabase, function (err) {
			if (err) {
				if (callback) callback(new Error('[DB] Unable to open multiple databases on ' + host + ':' + port + ' : ' + err.message));
			} else {
				if (callback) callback(null);
			}
		});
	}
	// Open multiple databases
	else if (typeof databases === 'string') {
		_openDatabase({host: host, port: port, database: databases}, function (err) {
			if (err) {
				if (callback) callback(new Error('[DB] Unable to open database ' + databases + ' on ' + host + ':' + port + ' : ' + err.message));
			} else {
				if (callback) callback(null);
			}
		});
	}
	// Unknown state
	else {
		if (callback) callback(new Error('[DB] Unable to open database: unknown error'));
	}
};

/**
 * Close a database connection
 * If no database given, close all the connections
 * If database not opened, just callback and return
 *
 * @param database the database name to disconnect, may be null if all the databases must be closed
 * @param callback function called when done returning an error or null
 */
var close = function (database, callback) {
	// Check for missing arguments
	if (typeof database === 'function') {
		callback = database;
		database = undefined;
	}

	// Close all the databases
	if (!database) {
		// Search opened databases
		var databases = [];
		for (var key in db) {
			databases.push(key);
		}
		// Close each database
		async.each(databases, _closeDatabase, function (err) {
			if (err) {
				if (callback) callback(new Error('[DB] Unable to close multiple databases: ' + err.message));
			} else {
				if (callback) callback(null);
			}
		});
	}
	// Close only the asked database
	else {
		_closeDatabase(database, function (err) {
			if (err) {
				if (callback) callback(new Error('[DB] Unable to close database ' + database + ': ' + err.message));
			} else {
				if (callback) callback(null);
			}
		});
	}
};

/**
 * Open a single database.
 * If the database is already opened, only log a warning
 * and callback.
 *
 * @param database an object with the host, port and database name to connect to
 * @param callback function called when done returning an error or null
 */
var _openDatabase = function (database, callback) {
	var dbName = database.database;
	// Check if a connection exists, if exists, callback and return
	if (db[dbName] !== undefined) {
		logger.warn('[DB] Unable to open "' + dbName + '" database connection: database already opened');
		if (callback) callback(null);
		return;
	}
	// Create the database connection
	var omsServer = new mongo.Server(database.host, database.port, {auto_reconnect: true});
	db[dbName] = new mongo.Db(dbName, omsServer, {safe: true});
	// Connect to the DB
	db[dbName].open(function (err, newDb) {
		if (err) {
			db[dbName] = undefined;
			if (callback) callback(new Error('Unable to connect to "' + dbName + '" database on ' + database.host + ':' + database.port + ' : ' + err));
		} else {
			db[dbName] = newDb;
			logger.info('[DB] Connected to "' + dbName + '" database');
			if (callback) callback(null);
		}
	});
};

/**
 * Close a single database.
 * If the database is not opened, only log a warning and callback.
 *
 * @param database the name of the database to close
 * @param callback function called when done returning an error or null
 */
 var _closeDatabase = function (database, callback) {
	// Check if a connection exists, if not exists, callback and return
	if (db[database] === undefined) {
		logger.warn('[DB] Unable to close "' + database + '" database connection: database not opened');
		if (callback) callback(null);
		return;
	}
	// Force close the connection
	db[database].close(true, function (err) {
		// If error or not, delete the connection
		db[database] = undefined
		// Log and callback
		if (err) {
			if (callback) callback(new Error('Unable to close "' + database + '" database connection: ' + err.message));
		} else {
			logger.info('[DB] Connection to "' + database + '" database closed');
			if (callback) callback(null);
		}
	});
};



/**
 * DAO class definition
 */

function Dao(collectionName, database) {
	this.database = typeof database !== 'undefined' ? database : 'oms';	// TODO extract
	this.collectionName = collectionName;
};



/**
 * Raw method: Update items in collection
 *
 * @param selector the mongoDB selector object
 * @param item the mongoDB data object
 * @param options the mongoDB options object
 * @param callback a callback containing null or the number of updated records
 */
Dao.prototype._update = function (selector, item, options, callback) {
	// Define locally the collectionName to use it in the nested functions
	var collectionName = this.collectionName;
	logger.info('[DB] Update/Replace item from ' + this.collectionName + ' set ' + JSON.stringify(item) + ' matching ' + JSON.stringify(selector));
	db[this.database].collection(this.collectionName, function (err, collection) {
		collection.update(selector, item, options, function (err, result) {
			if (err) {
				logger.warn('[DB] Error while updating items in ' + collectionName + ': ' + err.message);
				if (callback) callback(null);
			} else {
				logger.info('[DB] ' + result + ' items updated in ' + collectionName);
				if (callback) callback(result);
			}
		});
	});
};

/**
 * Raw method: Insert items in collection
 *
 * @param items the mongoDB data object (array or single object)
 * @param options the mongoDB options object
 * @param callback a callback containing null or an array of the inserted records
 */
Dao.prototype._insert = function (items, options, callback) {
	// Define locally the collectionName to use it in the nested functions
	var collectionName = this.collectionName;
	logger.info('[DB] Insert item(s) in ' + this.collectionName + ': ' + JSON.stringify(items));
	db[this.database].collection(this.collectionName, function (err, collection) {
		collection.insert(items, options, function (err, result) {
			if (err) {
				logger.warn('[DB] Error while inserting items in ' + collectionName + ': ' + err.message);
				if (callback) callback(null);
			} else {
				logger.info('[DB] ' + result.length + ' items inserted in ' + collectionName);
				if (callback) callback(result);
			}
		});
	});
};

/**
 * Raw method: Remove items in collection
 *
 * @param item the mongoDB data object
 * @param options the mongoDB options object
 * @param callback a callback containing null or the number of removed objects
 */
Dao.prototype._remove = function (selector, options, callback) {
	// Define locally the collectionName to use it in the nested functions
	var collectionName = this.collectionName;
	logger.info('[DB] Delete item(s) from ' + this.collectionName + ' matching ' + JSON.stringify(selector));
	db[this.database].collection(this.collectionName, function (err, collection) {
		collection.remove(selector, options, function (err, result) {
			if (err) {
				logger.warn('[DB] Error while deleting items in ' + collectionName + ': ' + err.message);
				if (callback) callback(null);
			} else {
				logger.info('[DB] ' + result + ' items deleted in ' + collectionName);
				if (callback) callback(result);
			}
		});
	});
};

/**
 * Convenient method: Find one item in collection
 *
 * @param query the mongoDB selector object
 * @param callback a callback containing null or the found object
 */
Dao.prototype.findOne = function (query, callback) {
	// Define locally the collectionName to use it in the nested functions
	var collectionName = this.collectionName;
	logger.info('[DB] Find one item from ' + this.collectionName + ' matching ' + JSON.stringify(query));
	db[this.database].collection(this.collectionName, function (err, collection) {
		collection.findOne(query, function (err, result) {
			if (err) {
				logger.warn('[DB] Error while searching one item in ' + collectionName + ' matching ' + JSON.stringify(query) + ': ' + err.message);
				if (callback) callback(null);
			} else {
				logger.info('[DB] Item found in ' + collectionName + ': ' + JSON.stringify(result));
				if (callback) callback(result);
			}
		});
	});
};

/**
 * Convenient method: Find one item in collection by id
 *
 * @param id the string id of the object to search in collection
 * @param callback a callback containing null or the found object
 */
Dao.prototype.findById = function (id, callback) {
	id = new BSON.ObjectID(new String(id));
	this.findOne({_id: id}, callback);
};

/**
 * Convenient method: Find multiple items in collection
 *
 * @param query the mongoDB selector object
 * @param callback a callback containing null or the found objects
 */
Dao.prototype.find = function (query, callback) {
	// Define locally the collectionName to use it in the nested functions
	var collectionName = this.collectionName;
	logger.info('[DB] Find all items from ' + this.collectionName + ' matching ' + JSON.stringify(query));
	db[this.database].collection(this.collectionName, function (err, collection) {
		collection.find(query).toArray(function (err, result) {
			if (err) {
				logger.warn('[DB] Error while searching multiple items in ' + collectionName + ' matching ' + JSON.stringify(query) + ': ' + err.message);
				if (callback) callback(null);
			} else {
				logger.info('[DB] Item found in ' + collectionName + ': ' + JSON.stringify(result));
				if (callback) callback(result);
			}
		});
	});
};

/**
 * Convenient method: Find all items in collection
 *
 * @param callback a callback containing null or the found objects
 */
Dao.prototype.findAll = function (callback) {
	this.find({}, callback);
};

/**
 * Convenient method: Insert items in collection
 *
 * @param items the mongoDB data object (array or single object)
 * @param callback a callback containing null or an array of the inserted records
 */
Dao.prototype.insert = function (item, callback) {
	this._insert(item, {continueOnError: true, w: 1}, callback);
};

/**
 * Convenient method: Update items in collection
 *
 * @param id the string id of the object to update in collection
 * @param item the mongoDB data object
 * @param callback a callback containing null or the number of updated records
 */
Dao.prototype.update = function (id, item, callback) {
	id = new BSON.ObjectID(new String(id));
	item = {$set: item}
	this._update({'_id': id}, item, {}, callback);
};

/**
 * Convenient method: Replace items in collection
 *
 * @param id the string id of the object to replace in collection
 * @param item the mongoDB data object
 * @param callback a callback containing null or the number of replaced records
 */
Dao.prototype.replace = function (id, item, callback) {
	id = new BSON.ObjectID(new String(id));
	this._update({'_id': id}, item, {}, callback);
};

/**
 * Convenient method: Remove one item in collection
 *
 * @param id the string id of the object to remove of the collection
 * @param callback a callback containing null or the number of removed records
 */
Dao.prototype.remove = function (id, callback) {
	id = new BSON.ObjectID(new String(id));
	this._remove({'_id': id}, {}, callback);
};

/**
 * Convenient method: Listen to new documents in collection
 *
 * @param callback a callback containing null or the new inserted document
 */
Dao.prototype.listen = function (callback) {
	logger.info('[DB] Listen for new documents from ' + this.collectionName);
	db[this.database].collection(this.collectionName, function (err, collection) {
		var latest = collection.find({}).sort({ $natural: -1 }).limit(1);
		latest.nextObject(function (err, doc) {
			var query = {_id: { $gt: doc._id }};
			var options = {tailable: true, awaitdata: true, numberOfRetries: -1};
			var cursor = collection.find(query, options).sort({ $natural: 1 });
			var next = function () {
				cursor.nextObject(function (err, item) {
				callback(item);
				next();
				});
			};
			next();
		});
	});
};



/**
 * Exports
 */

// variables
exports.BSON = BSON;
// methods
exports.open = open;
exports.close = close;
exports.Dao = Dao;