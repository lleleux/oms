/**
 * Load modules
 */

var mongo = require('mongodb');
var logger = require('logger');



/**
 * Variables
 */

// DB Server
var db = [];
// BSON
var BSON = mongo.BSONPure;



/**
 * Open a database connection
 * If an argument is missing, throws an exception
 * If database already opened, just callback and return
 */

var open = function (host, port, database, callback) {
	// Check for missing arguments
	if (host === undefined) {
		logger.error('[DB] Unable to open database: undefined host');
		throw '[DB] Unable to open database: undefined host';
	}
	if (port === undefined) {
		logger.error('[DB] Unable to open database: undefined port');
		throw '[DB] Unable to open database: undefined port';
	}
	if (database === undefined) {
		logger.error('[DB] Unable to open database: undefined database');
		throw '[DB] Unable to open database: undefined database';
	}

	// Check if a connection exists, if exists, callback and return
	if (db[database] !== undefined) {
		logger.info('[DB] Unable to open database ' + database + ': database already opened');
		if (callback) callback();
		return;
	}

	// Create the database connection
	var omsServer = new mongo.Server(host, port, {auto_reconnect: true});
	db[database] = new mongo.Db(database, omsServer, {safe: true});
	// Connect to the DB
	db[database].open(function (error, newDb) {
		if (!error) {
			logger.info('[DB] Connected to ' + database + ' database');
			if (callback) callback();
		} else {
			logger.warn('[DB] Unable to Connect to ' + database + ' database ' + error);
		}
	});
};



/**
 * Close a database connection
 * If no database given, close all the connections
 * If database not opened, just callback and return
 */

var close = function (database, callback) {
	// Check for missing arguments
	if (database === undefined ) {
		logger.error('[DB] Unable to close database: undefined database');
		if (callback) callback();
		return;
	}

	// Check if a connection exists, if not exists, callback and return
	if (db[database] === undefined) {
		logger.info('[DB] Unable to close database ' + database + ': database not opened');
		if (callback) callback();
		return;
	}

	// Force close the connection
	db[database].close(true, function (error) {
		if (error) {
			logger.info('[DB] Unable to close database connection');
		} else {
			logger.info('[DB] Connection to database closed');
		}
		if (callback) callback();
	});
}



/**
 * DAO class definition
 */

function Dao(collectionName, database) {
	this.database = typeof database !== 'undefined' ? database : 'oms';	// TODO extract
	this.collectionName = collectionName;
};



/**
 * DAO generic methods
 */

Dao.prototype._update = function (selector, item, options, callback) {
	var collectionName = this.collectionName;
	logger.info('[DB] Update/Replace item from ' + collectionName);
	db[this.database].collection(collectionName, function (error, collection) {
		collection.update(selector, item, options, function (error, result) {
			if (error) {
				logger.warn('[DB] Error while updating items in ' + collectionName + ': ' + error);
			}
			logger.info('[DB] ' + result + ' items updated from ' + collectionName);
			// Result is the number of updated records
			if (callback) callback(result);
		});
	});
};

Dao.prototype._insert = function (item, options, callback) {
	var collectionName = this.collectionName;
	logger.info('[DB] Insert item(s) in ' + collectionName + ': ' + JSON.stringify(item));
	db[this.database].collection(collectionName, function (error, collection) {
		collection.insert(item, options, function (error, result) {
			if (result === undefined) {
				result = [];
			}
			logger.info('[DB] ' + result.length + ' items inserted in ' + collectionName);
			// Result is an array of inserted records
			if (callback) callback(result);
		});
	});
};

Dao.prototype._remove = function (selector, options, callback) {
	var collectionName = this.collectionName;
	logger.info('[DB] Delete item(s) from ' + collectionName + ' matching ' + JSON.stringify(selector));
	db[this.database].collection(collectionName, function (error, collection) {
		collection.remove(selector, options, function (error, result) {
			if (error) {
				logger.warn('[DB] Error while deleting items in ' + collectionName + ' with selector ' + JSON.stringify(selector) + ': ' + error);
			} else {
				logger.info('[DB] ' + result + ' items deleted from ' + collectionName);
			}
			// Result is the number of deleted records
			if (callback) callback(result);
		});
	});
};



/**
 * Dao commonly used methods
 */

Dao.prototype.findOne = function (query, callback) {
	logger.info('[DB] Find one item from ' + this.collectionName + ' matching ' + JSON.stringify(query));
	db[this.database].collection(this.collectionName, function (error, collection) {
		collection.findOne(query, function (error, item) {
			logger.info('[DB] Item found : ' + item);
			if (callback) callback(item);
		});
	});
};

Dao.prototype.findById = function (id, callback) {
	id = new BSON.ObjectID(new String(id));
	this.findOne({_id: id}, callback);
};

Dao.prototype.find = function (query, callback) {
	logger.info('[DB] Find all items from ' + this.collectionName + ' matching ' + JSON.stringify(query));
	db[this.database].collection(this.collectionName, function (error, collection) {
		collection.find(query).toArray(function (error, items) {
			logger.info('[DB] ' + items.length + ' items found');
			if (callback) callback(items);
		});
	});
};

Dao.prototype.findAll = function (callback) {
	this.find({}, callback);
};

Dao.prototype.insert = function (item, callback) {
	this._insert(item, {continueOnError: true, w: 1}, callback);
};

Dao.prototype.update = function (id, item, callback) {
	id = new BSON.ObjectID(new String(id));
	item = {$set: item}
	this._update({'_id': id}, item, {}, callback);
};

Dao.prototype.replace = function (id, item, callback) {
	id = new BSON.ObjectID(new String(id));
	this._update({'_id': id}, item, {}, callback);
};

Dao.prototype.remove = function (id, callback) {
	id = new BSON.ObjectID(new String(id));
	this._remove({'_id': id}, {}, callback);
};

Dao.prototype.listen = function (callback) {
	logger.info('[DB] Listen for new documents from ' + this.collectionName);
	db[this.database].collection(this.collectionName, function (error, collection) {
		var latest = collection.find({}).sort({ $natural: -1 }).limit(1);
		latest.nextObject(function (error, doc) {
			var query = {_id: { $gt: doc._id }};
			var options = {tailable: true, awaitdata: true, numberOfRetries: -1};
			var cursor = collection.find(query, options).sort({ $natural: 1 });
			var next = function () {
				cursor.nextObject(function (error, message) {
				callback(message);
				next();
				});
			};
			next();
		});
	});

}



/**
 * Exports
 */

// variables
exports = module.exports = db;
exports.BSON = BSON;
// methods
exports.open = open;
exports.close = close;
exports.Dao = Dao;