/**
 * Load modules
 */

// Built-in
var mongo = require('mongodb');
var async = require('async');
// Global
var logger = require('logger');



/**
 * Variables
 */

// DB Server
var db = {};
// BSON
var BSON = mongo.BSONPure;



/**
 * Open a database connection
 * If an argument is missing, throws an exception
 * If database already opened, just callback and return
 *
 * The database argument can be an array or a string to
 * open multiple connections once.
 */

var open = function (host, port, databases, callback) {
	// Check for missing arguments
	if (host === undefined) {
		throw new Error('[DB] Unable to open database: undefined host');
	}
	if (port === undefined) {
		throw new Error('[DB] Unable to open database: undefined port');
	}
	if (databases === undefined) {
		throw new Error('[DB] Unable to open database: undefined database');
	}

	// Open a single database
	if (typeof databases !== 'string') {
		// Add host/port information
		for (var key in databases) {
			databases[key] = {host: host, port: port, database: databases[key]};
		}
		// Open each database
		async.each(databases, _openDatabase, function (err) {
			if (err) { throw err; }
			else { if (callback) callback(); }
		});
	}
	// Open multiple databases
	else {
		_openDatabase({host: host, port: port, database: databases}, function (err) {
			if (err) { throw err; }
			else { if (callback) callback(); }
		});
	}
};

// Database is an object with the host, port, and database name
var _openDatabase = function (database, callback) {
	var dbName = database.database;
	// Check if a connection exists, if exists, callback and return
	if (db[dbName] !== undefined) {
		logger.warn('[DB] Unable to open "' + dbName + '" database connection: database already opened');
		if (callback) callback();
		return;
	}
	// Create the database connection
	var omsServer = new mongo.Server(database.host, database.port, {auto_reconnect: true});
	db[dbName] = new mongo.Db(dbName, omsServer, {safe: true});
	// Connect to the DB
	db[dbName].open(function (error, newDb) {
		if (error) {
			db[dbName] = undefined;
			var err = new Error('[DB] Unable to connect to "' + dbName + '"" database:' + error);
			if (callback) callback(err);
		} else {
			db[dbName] = newDb;
			logger.info('[DB] Connected to "' + dbName + '"" database');
			if (callback) callback();
		}
	});
};



/**
 * Close a database connection
 * If no database given, close all the connections
 * If database not opened, just callback and return
 */

var close = function (database, callback) {
	// Check for missing arguments
	if (typeof database === 'function') {
		callback = database;
		database = undefined;
	}

	// Close all the databases
	if (!database) {
		// Search opened databases
		var databases = [];
		for (var key in db) {
			databases.push(key);
		}
		// Close each database
		async.each(databases, _closeDatabase, function (err) {
			if (err) { throw err; }
			else { if (callback) callback(); }
		});
	}
	// Close only the asked database
	else {
		_closeDatabase(database, function (err) {
			if (err) { throw err; }
			else { if (callback) callback(); }
		});
	}
}

// Database is a string representing the database name
var _closeDatabase = function (database, callback) {
	// Check if a connection exists, if not exists, callback and return
	if (db[database] === undefined) {
		logger.warn('[DB] Unable to close "' + database + '"" database connection: database not opened');
		if (callback) callback();
		return;
	}
	// Force close the connection
		var databases = [];
		for (var key in db) {
			databases.push(key);
		}
	db[database].close(true, function (error) {
		// If error or not, delete the connection
		db[database] = undefined
		// Log and callback
		if (error) {
			var err = new Error('[DB] Unable to close "' + database + '" database connection: ' + error);
			if (callback) callback(err);
		} else {
			logger.info('[DB] Connection to "' + database + '" database closed');
			if (callback) callback();
		}
	});
};



/**
 * DAO class definition
 */

function Dao(collectionName, database) {
	this.database = typeof database !== 'undefined' ? database : 'oms';	// TODO extract
	this.collectionName = collectionName;
};



/**
 * DAO generic methods
 */

Dao.prototype._update = function (selector, item, options, callback) {
	var collectionName = this.collectionName;
	logger.info('[DB] Update/Replace item from ' + collectionName + ' set: ' + JSON.stringify(item));
	db[this.database].collection(collectionName, function (error, collection) {
		collection.update(selector, item, options, function (error, result) {
			if (error) {
				logger.warn('[DB] Error while updating items in ' + collectionName + ': ' + error);
			}
			logger.info('[DB] ' + result + ' items updated from ' + collectionName);
			// Result is the number of updated records
			if (callback) callback(result);
		});
	});
};

Dao.prototype._insert = function (item, options, callback) {
	var collectionName = this.collectionName;
	logger.info('[DB] Insert item(s) in ' + collectionName + ': ' + JSON.stringify(item));
	db[this.database].collection(collectionName, function (error, collection) {
		collection.insert(item, options, function (error, result) {
			if (result === undefined) {
				result = [];
			}
			logger.info('[DB] ' + result.length + ' items inserted in ' + collectionName);
			// Result is an array of inserted records
			if (callback) callback(result);
		});
	});
};

Dao.prototype._remove = function (selector, options, callback) {
	var collectionName = this.collectionName;
	logger.info('[DB] Delete item(s) from ' + collectionName + ' matching ' + JSON.stringify(selector));
	db[this.database].collection(collectionName, function (error, collection) {
		collection.remove(selector, options, function (error, result) {
			if (error) {
				logger.warn('[DB] Error while deleting items in ' + collectionName + ' with selector ' + JSON.stringify(selector) + ': ' + error);
			} else {
				logger.info('[DB] ' + result + ' items deleted from ' + collectionName);
			}
			// Result is the number of deleted records
			if (callback) callback(result);
		});
	});
};



/**
 * Dao commonly used methods
 */

Dao.prototype.findOne = function (query, callback) {
	logger.info('[DB] Find one item from ' + this.collectionName + ' matching ' + JSON.stringify(query));
	db[this.database].collection(this.collectionName, function (error, collection) {
		collection.findOne(query, function (error, item) {
			logger.info('[DB] Item found : ' + item);
			if (callback) callback(item);
		});
	});
};

Dao.prototype.findById = function (id, callback) {
	id = new BSON.ObjectID(new String(id));
	this.findOne({_id: id}, callback);
};

Dao.prototype.find = function (query, callback) {
	logger.info('[DB] Find all items from ' + this.collectionName + ' matching ' + JSON.stringify(query));
	db[this.database].collection(this.collectionName, function (error, collection) {
		collection.find(query).toArray(function (error, items) {
			logger.info('[DB] ' + items.length + ' items found');
			if (callback) callback(items);
		});
	});
};

Dao.prototype.findAll = function (callback) {
	this.find({}, callback);
};

Dao.prototype.insert = function (item, callback) {
	this._insert(item, {continueOnError: true, w: 1}, callback);
};

Dao.prototype.update = function (id, item, callback) {
	id = new BSON.ObjectID(new String(id));
	item = {$set: item}
	this._update({'_id': id}, item, {}, callback);
};

Dao.prototype.replace = function (id, item, callback) {
	id = new BSON.ObjectID(new String(id));
	this._update({'_id': id}, item, {}, callback);
};

Dao.prototype.remove = function (id, callback) {
	id = new BSON.ObjectID(new String(id));
	this._remove({'_id': id}, {}, callback);
};

Dao.prototype.listen = function (callback) {
	logger.info('[DB] Listen for new documents from ' + this.collectionName);
	db[this.database].collection(this.collectionName, function (error, collection) {
		var latest = collection.find({}).sort({ $natural: -1 }).limit(1);
		latest.nextObject(function (error, doc) {
			var query = {_id: { $gt: doc._id }};
			var options = {tailable: true, awaitdata: true, numberOfRetries: -1};
			var cursor = collection.find(query, options).sort({ $natural: 1 });
			var next = function () {
				cursor.nextObject(function (error, message) {
				callback(message);
				next();
				});
			};
			next();
		});
	});

}



/**
 * Exports
 */

// variables
exports.BSON = BSON;
// methods
exports.open = open;
exports.close = close;
exports.Dao = Dao;