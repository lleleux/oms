/**
 * =============================
 *
 * Manages the communication between the agent and the server.
 * Abstracts the protocol (XML, JSON...)
 *
 * Start the pairing process when connected.
 * Handle the messages when received.
 *
 * =============================
 *
 * Attributes : /
 *
 * Methods :
 *		- getScript()
 *
 * Events :
 *		- waiting
 *		- paired
 *
 * =============================
 */



/**
 * Load modules
 */

// Built-in
var fs = require('fs');
var events = require('events');
// Global
var logger = require('logger');
var commander = require('commander');
// Custom
var connection = require('connection');



/**
 * Variables
 */

// Event emitter
var eventEmitter = new events.EventEmitter();



/**
 * Raw method for sending a message
 * Use the connection module to send a message
 */

var send = function (message) {
	logger.info('[Protocol] Sending ' + message.name);
	message.sendDate = new Date().getTime();
	connection.send(JSON.stringify(message));
};



/**
 * Build and send messages
 */

var sendPairingRequest = function () {
	var message = {};
	message.name = 'pairingRequest';
	message.agent = {};
	message.agent.version = '1.0';
	message.agent.installDate = new Date().getTime();
	send(message);
};

var sendScriptRequest = function (commandName) {
	var message = {};
	message.name = 'getScriptRequest';
	message.commandName = commandName;
	send(message);
};

var sendResult = function (result) {
	var message = result;
	message.name = 'result';
	send(message);
}



/**
 * Pair the agent with the server.
 */

connection.on('connected', function () {
	sendPairingRequest();
});



/**
 * Generic method to handle protocol messages.
 * This method is generic and forward the request to a Handler.
 */

connection.on('message', function (message) {
	logger.info("[Protocol] Message received: " + message);
	message = JSON.parse(message);
	var name = message.name.charAt(0).toUpperCase() + message.name.slice(1);
	// Call the right handler method, if not found, call the unknownMessage method
	if (handler['handle' + name] !== undefined) {
		logger.info('[Protocol] Handle ' + message.name);
		handler['handle' + name](message);
	} else {
		handler.handleUnknownMessage(message);
	}
});



/**
 * Handler to handle the protocol messages
 */

var Handler = function () {

	this.handlePairingResponse = function (message) {
		if (message.returnCode === 0) {
			eventEmitter.emit('connected');
		} else if (message.returnCode === 1) {
			eventEmitter.emit('waiting');
		} else {
			logger.warn('[Protocol] Wrong returnCode received in pairingResponse: ' + message.returnCode);
		}
	};

	this.handleCommand = function (message) {
		var result = commander.command(message);
		result.on('done', function(res) {
			sendResult(res);
		});
	};

	this.handleScript = function(message) {
		// Execute the script and send the result
		var executeScript = function () {
			var result = commander.script(message);
			result.on('done', function(res) {
				sendResult(res);
			});
		}
		// Check if the script is local, and ask the script to the manager if needed
		if (!commander.isScriptLocal(message.scriptName, message.version)) {
			if (message.script === undefined) {
				protocol.getScript(message.scriptName);
			} else {
				// Add the script and execute it when added
				commander.addScript(message.scriptName, message.version, message.script, function () {
					executeScript();
				});
			}
		} else {
			executeScript();
		}
	}

	this.handleUnknownMessage = function (message) {
		logger.warn('[Protocol] Unknown message received: ' + message);
	};

};

var handler = new Handler();



/**
 * Public methods
 */

var getScript = function (commandName) {
	sendScriptRequest(commandName);
};



/**
 * Exports
 */

// events
exports = module.exports = eventEmitter;
// methods
exports.getScript = getScript;