/**
 * =============================
 *
 * Certification authority manager
 *
 * =============================
 *
 * Attributes : /
 *
 * Methods : /
 *
 * Events : /
 *
 * =============================
 */



/**
 * Load modules
 */

// Built-in
var fs = require('fs');
// Global
var logger = require('logger');
var utils = require('utils');
var Dao = require('db').Dao;
// Custom
var dbCommander = require('dbCommander');



/**
 * Variables
 */

// DAO
var config = new Dao('config');
var devices = new Dao('devices');
var installs = new Dao('installs');



/**
 * Initialize a new CA. Create the directory, a key, a certificate...
 */

var initialize = function (callback) {
	callback = undefined;
	config.findOne({name: 'certificationAuthority'}, function (ca) {
		// Create directory if needed
		if (!fs.existsSync(ca.directory)) {
			logger.info('[CA] Creating CA directory : ' + ca.directory);
			utils.mkdirpSync(ca.directory);
		}
		// Create private key and certificate if needed
		_createCaKey(ca, function () {
			_createCaCert(ca, callback);
		})
	});
};



/**
 * Create Agent private key and certificate
 */

var initializeInstall = function (installId, callback) {
	config.findOne({name: 'certificationAuthority'}, function (ca) {
		// Create private key and certificate if needed
		_createAgentKey(ca, installId, function () {
			_createAgentCert(ca, installId, callback);
		})
	});
};



/**
 * Ban agent by setting his certificate in the CRL
 * Generate the new crl.
 *
 * Only works with "installed" and "created" agents.
 */

var banAgent = function (agentId, callback) {
	logger.info('[CA] Ban the agent: ' + agentId);
	// Get the CA infos
	config.findOne({name: 'certificationAuthority'}, function (ca) {
		var tmpDirectory = ca.directory + '/' + agentId;
		// Create tmp directory if needed
		if (!fs.existsSync(tmpDirectory)) {
			utils.mkdirpSync(tmpDirectory);
		}
		// Create certificate tmp file
		installs.findById(agentId, function (agent) {
			fs.writeFileSync(tmpDirectory + '/agent.crt', agent.certificate);
			var parameters = {
				ca_crl_filename:	ca.crl.filename,
				cert_directory:		tmpDirectory,
				cert_filename:		'agent.crt',
				ca_directory:		ca.directory,
				ca_config_filename:	ca.config_filename,
				passphrase:			ca.private_key.passphrase
			};
			dbCommander.command('revoke_certificate', parameters, function (result) {
				utils.rmdirrf(tmpDirectory);
				dbCommander.command('generate_crl', parameters, function (result) {
					if (result.code === 0) {
						config.update(ca.id, {crl: {last_generation: new Date().getTime()}}, callback);
					}
				});
			});
		});
	});
};



/**
 * Create CA private key if needed. The callback is called when the key is created
 * or if no key must be created...
 */

var _createCaKey = function (ca, callback) {
	// Create private key if needed
	if (!fs.existsSync(ca.directory + '/' + ca.private_key.filename)) {
		logger.info('[CA] Creating CA private key : ' + ca.directory + '/' + ca.private_key.filename);
		var parameters = {
			ca_directory:	ca.directory,
			filename:		ca.private_key.filename,
			passphrase:		ca.private_key.passphrase
		};
		dbCommander.command('create_ca_private_key', parameters, callback);
	} else {
		logger.info('[CA] CA private key found at : ' + ca.directory + '/' + ca.private_key.filename);
		if (callback) callback();
	}
};



/**
 * Create CA certificate if needed. The callback is called when the certificate is created
 * or if no certificate must be created...
 */

var _createCaCert = function (ca, callback) {
	if (!fs.existsSync(ca.directory + '/' + ca.certificate.filename)) {
		logger.info('[CA] Creating CA certificate : ' + ca.directory + '/' + ca.certificate.filename);
		var parameters = {
			ca_directory:	ca.directory,
			key_filename:	ca.private_key.filename,
			passphrase:		ca.private_key.passphrase,
			validity:		ca.certificate.validity,
			crt_filename:	ca.certificate.filename,
			C:				ca.certificate.C,
			CN:				ca.certificate.CN,
			O:				ca.certificate.O,
			OU:				ca.certificate.OU,
			L:				ca.certificate.L,
			ST:				ca.certificate.ST
		};
		dbCommander.command('create_ca_certificate', parameters, callback);
	} else {
		logger.info('[CA] CA certificate found at : ' + ca.directory + '/' + ca.certificate.filename);
		if (callback) callback();
	}
};



/**
 * Create an agent private key and store it in DB
 * No file is created
 */

var _createAgentKey = function (ca, installId, callback) {
	logger.info('[CA] Creating private key for agent: ' + installId);
	dbCommander.command('create_agent_private_key', {}, function (result) {
		if (result.code == 0) {
			installs.update(installId, {private_key: result.data}, callback);
		} else {
			logger.warn('[CA] Unable to create agent private key: code = ' + result.code + ', output = ' + result.data)
		}
	});
};



/**
 * Create an agent Certificate
 * Before, create a temp CSR
 * Some temporary files are created locally but deleted after use
 * The agent MUST have a private key before creating a Certificate
 */

var _createAgentCert = function (ca, installId, callback) {
	logger.info('[CA] Creating certificate for install: ' + installId);
	var tmpDirectory = ca.directory + '/' + installId;
	// Create tmp directory if needed
	if (!fs.existsSync(tmpDirectory)) {
		utils.mkdirpSync(tmpDirectory);
	}
	// Create private key tmp file
	installs.findById(installId, function (install) {
		fs.writeFileSync(tmpDirectory + '/agent.key', install.private_key);
		var parameters = {
			tmp_directory:		tmpDirectory,
			key_filename:		'agent.key',
			req_filename:		'agent.csr',
			C:					ca.certificate.C,
			CN:					installId,
			O:					ca.certificate.O,
			OU:					ca.certificate.OU,
			L:					ca.certificate.L,
			ST:					ca.certificate.ST,
			ca_directory:		ca.directory,
			ca_config_filename:	ca.config_filename,
			validity:			ca.certificate.validity,
			passphrase:			ca.private_key.passphrase
		};
		dbCommander.command('create_agent_certificate', parameters, function (result) {
			utils.rmdirrf(tmpDirectory);
			installs.update(installId, {certificate: result.data}, callback);
		});
	});
};



/**
 * Exports
 */

// Methods
exports.initialize = initialize;
exports.initializeInstall = initializeInstall;