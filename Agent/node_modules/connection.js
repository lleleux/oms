/**
 * =============================
 *
 * Manages the connection to the server. Abstract the connection,
 * sending data, receiving data...
 *
 * Binding : TLS Socket
 *
 * =============================
 *
 * Attributes :
 *		- server
 *			- host
 *			- port
 *		- agent
 *			- reconnectionDelay
 *			- autoReconnect
 *			- tlsPrivateKeyPath
 *			- tlsCertificatePath
 *			- tlsPrivateKey
 *			- tlsCertificate
 *			- rejectUnauthorized
 *
 * Methods :
 *		- connect
 *		- disconnect
 *		- send(message)
 *
 * Events :
 *		- connected
 *		- disconnected
 *		- stopped
 *		- message(data)
 *
 * =============================
 */



/**
 * Load modules
 */

// Built-in
var tls = require('tls');
var fs = require('fs');
var events = require('events');
// Global
var config = require('config');
var logger = require('logger');



/**
 * Variables
 */

// Configuration
var server = {
	host:		config.get('serverHost'),
	port:		config.get('serverPort')
};

var agent = {
	reconnectionDelay:		config.get('reconnectionDelay'),
	autoReconnect:			true,
	tlsPrivateKeyPath:		config.get('tlsPrivateKey'),
	tlsCertificatePath:		config.get('tlsCertificate'),
	tlsPrivateKey:			fs.readFileSync(config.get('tlsPrivateKey')),
	tlsCertificate:			fs.readFileSync(config.get('tlsCertificate')),
	caCertificate:			fs.readFileSync(config.get('caCertificate')),
	rejectUnauthorized:		true
};

// Agent clear text stream
var stream;

// Reconnection timer
var timer;

// Event emitter
var eventEmitter = new events.EventEmitter();

// Server options
var options = {
	key:				agent.tlsPrivateKey,
	cert:				agent.tlsCertificate,
	ca:					agent.caCertificate,		// TODO remove when real Certificate for server
	rejectUnauthorized:	true
};



/**
 * Private connection management
 */

var startConnecting = function () {
	if (timer === undefined) {
		timer = setInterval(function () {
			stream = tls.connect(server.port, server.host, options);
			setHandlers();
		}, agent.reconnectionDelay);
		stream = tls.connect(server.port, server.host, options);
		setHandlers(stream);
	}
};

var stopConnecting = function () {
	clearInterval(timer);
	timer = undefined;
};



/**
 * Events handling on the stream
 */

var setHandlers = function () {

	 // When connected
	stream.on('secureConnect', function () {
		stopConnecting();
		logger.info('[Connection] Connected');
		eventEmitter.emit('connected');
	});

	// When data is received
	stream.on('data', function (data) {
		eventEmitter.emit('message', data);
	});

	// When the connection is ended by the server
	stream.on('end', function () {
		logger.warn('[Connection] Connection closed by the server');
	});

	// When an error occurs on the stream
	stream.on('error', function (error) {
		logger.warn('[Connection] Connection error: (' + error + ')');
		// TODO change status when error = ECONNREFUSED because it goes not in the close event
	});

	// When the stream is closed
	stream.on('close', function () {
		logger.warn('[Connection] Disconnected');
		if (agent.autoReconnect) {
			// send event only when autReconnect is true because if false, the agent is stopped
			eventEmitter.emit('disconnected');
			startConnecting();
		}
	});

};



/**
 * Public methods
 */

var connect = function () {
	agent.autoReconnect = true;
	startConnecting();
};

var disconnect = function () {
	agent.autoReconnect = false;
	stopConnecting();
	stream.end();
	logger.warn('[Connection] Stopped');
	eventEmitter.emit('stopped');
};

var send = function (message) {
	stream.write(message);
};



/**
 * Exports
 */

// events
exports = module.exports = eventEmitter;
// attributes
exports.server = server;
exports.agent = agent;
// methods
exports.connect = connect;
exports.disconnect = disconnect;
exports.send = send;