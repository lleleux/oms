/**
 * =============================
 *
 * Manages the communication between the agents and the server.
 * Abstracts the protocol (XML, JSON...)
 *
 * Handle the messages when received.
 *
 * =============================
 *
 * Attributes : /
 *
 * Methods :
 * 		- sendCommand(agentId, command)
 *		- sendScript(agentId, name, version, arguments)
 *
 * Events : /
 *
 * =============================
 */



/**
 * Load modules
 */

// Global
var logger = require('logger');
var db = require('db');
var utils = require('utils');
// Custom
var connection = require('connection');



/**
 * Variables
 */

// Dao
var devicesDao = new db.Dao('devices');
var installsDao = new db.Dao('installs');
// List of connected agents
var agents = {};



/**
 * When a new message is received,
 *
 * Generic method to handle protocol messages.
 * This method is generic and forward the request to a Handler.
 */

connection.on('message', function (message, agentId) {
	// Parse message
	message = JSON.parse(message);
	logger.info('[Protocol] Message received from ' + agentId + ': ' + message);
	// Get mesage type
	var name = message.name.charAt(0).toUpperCase() + message.name.slice(1);
	// Call the right handler method, if not found, call the unknownMessage method
	if (handler['handle' + name] !== undefined) {
		if (agents[agentId] && name === 'PairingRequest') {
			logger.warn('[Protocol] Paired agent ' + agentId + ' asking for pairing request');
			_sendError(agentId, 'You are already paired... No need to pair again.');
		} else if (!agents[agentId] && name !== 'PairingRequest') {
			logger.warn('[Protocol] Unpaired agent ' + agentId + ' asking for something else than pairing...');
			_sendError(agentId, 'You must be paired to send messages to the server.');
		} else {
			logger.info('[Protocol] Handle ' + message.name);
			handler['handle' + name](message, agentId);
		}
	} else {
		handler.handleUnknownMessage(message);
	}
});



/**
 * Listen to agent disconnection events...
 * Update their status in DB, only if a stopped message
 * was not received before.
 */

connection.on('disconnection', function (agentId) {
	delete agents[agentId];
	devicesDao.findById(agentId, function (err, device) {
		if (device) {
			if (device.agent.status === 'connected') {
				devicesDao.update(agentId, {'agent.status': 'disconnected', 'agent.disconnectionDate': new Date().getTime()});
			} else {
				logger.warn('[Protocol] Error during disconnection, agent has status "' + device.agent.status + '" instead of "connected".');
			}
		}
	});
});



/**
 * Send methods
 */

var _send = function (message, agentId) {
 	logger.info('[Protocol] Sending ' + message.name);
	message.sendDate = new Date().getTime();
	connection.send(JSON.stringify(message), agentId);
};

 var _sendPairingResponse = function (agentId, code, token) {
	var message = {};
	message.name = 'pairingResponse';
	message.returnCode = code;
	if (token) {
		message.token = token;
	}
	_send(message, agentId);
 };

var sendCommand = function (agentId, command) {
	var message = {};
	message.name = 'command';
	message.requestId = 1;
	message.command = new Buffer(command).toString('base64');
	_send(message, agentId);
};

var sendScript = function (agentId, name, version, arguments) {
	var message = {};
	message.name = 'script';
	message.requestId = 2;
	message.scriptName = name;
	message.version = version;
	message.arguments = arguments;
	_send(message, agentId);
};

var _sendError = function (agentId, reason) {
	var message = {};
	message.name = 'error';
	message.reason = reason;
	_send(message, agentId);
}



/**
 * Handler to handle the protocol messages
 */

var Handler = function () {

	this.handlePairingRequest = function (message, agentId) {
		devicesDao.findById(agentId, function (err, device) {
			// If device found, send PAIRED
			if (device) {
				// Check the token
				if (message.token !== device.agent.token) {
					logger.warn('[Protocol] Wrong token received from agent ' + agentId +': ' + message.token + ' instead of ' + device.agent.token);
					_sendError(agentId, 'Bad token passed: ' + message.token);
				}
				// First connection after accepted, connect it.
				if (device.agent.status === 'accepted') {
					var data = {
						'agent.status': 				'connected',
						'agent.firstConnectionDate': 	new Date().getTime(),
						'agent.lastConnectionDate': 	new Date().getTime()
					};
					devicesDao.update(agentId, data, function (err, result) {
						_sendPairingResponse(agentId, 0);
						agents[agentId] = '1';
					});
				}
				// Problem because connected but not in table ?
				else if (device.agent.status === 'connected') {
					// TODO
				}
				// In stopped/disconnected state, just connect...
				else  if (device.agent.status === 'disconnected' || device.agent.status === 'stopped') {
					var data = {
						'agent.status': 				'connected',
						'agent.lastConnectionDate': 	new Date().getTime()
					};
					devicesDao.update(agentId, data, function (err, result) {
						_sendPairingResponse(agentId, 0);
						agents[agentId] = '1';
					});
				} else {
					logger.warn('[Protocol] Agent ' + agentId + ' in invalid status: ' + install.status);
				}
			}
			// If device not found, set the activation time if not set, and send WAITING
			else {
				installsDao.findById(agentId, function (err, install) {
					// If no install found, unknown state...
					if (!install) {
						logger.warn('[Protocol] Unknown agent ' + agentId + ' connected !!! Check the CRL, certificates...');
					}
					// If first connection, send the token
					else if (install.status === 'created') {
						var token = utils.getToken();
						installsDao.update(agentId, {status: 'installed', activationDate: new Date().getTime(), token: token});
						installsDao._update({_id: new db.BSON.ObjectID(new String(agentId))}, {$unset: {private_key: 1}});
						_sendPairingResponse(agentId, 1, token);
					}
					// If token send but agent not yet accepted/rejected, send just "wait"
					else if (install.status === 'installed') {
						// Check the token
						if (message.token !== install.token) {
							logger.warn('[Protocol] Wrong token received from agent ' + agentId +': ' + message.token + ' instead of ' + install.token);
							_sendError(agentId, 'Bad token passed: ' + message.token);
						}
						// Send "wait"
						else {
							_sendPairingResponse(agentId, 1);
						}
					}
					// If in another status
					else {
						logger.warn('[Protocol] Agent ' + agentId + ' in invalid status: ' + install.status);
					}
				});
			}
		});
	};

	this.handleResult = function (message, agentId) {
		// TODO store in database
	};

	this.handleUnknownMessage = function (message) {
		logger.warn('[Protocol] Unknown message received : ' + message);
	};

};

var handler = new Handler();



/**
 * Exports
 */

// methods
exports.sendCommand = sendCommand;
exports.sendScript = sendScript;